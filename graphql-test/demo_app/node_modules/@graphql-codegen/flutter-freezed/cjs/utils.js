"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringIsNotEmpty = exports.atJsonKeyDecorator = exports.escapeDartKeyword = exports.isDartKeyword = exports.dartCasing = exports.appliesOnBlock = exports.nodeIsObjectType = exports.resetIndex = exports.arrayWrap = exports.strToList = void 0;
//#region helpers
const change_case_all_1 = require("change-case-all");
const graphql_1 = require("graphql");
const config_value_js_1 = require("./config/config-value.js");
const plugin_config_js_1 = require("./config/plugin-config.js");
const strToList = (str) => str.length < 1 ? [] : str.split(/\s*,\s*/gim).filter(s => s.length > 0);
exports.strToList = strToList;
const arrayWrap = (value) => value === undefined ? [] : Array.isArray(value) ? value : [value];
exports.arrayWrap = arrayWrap;
const resetIndex = (regexp) => (regexp.lastIndex = 0);
exports.resetIndex = resetIndex;
const nodeIsObjectType = (node) => node.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || node.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION;
exports.nodeIsObjectType = nodeIsObjectType;
const appliesOnBlock = (configAppliesOn, blockAppliesOn) => configAppliesOn.some(a => blockAppliesOn.includes(a));
exports.appliesOnBlock = appliesOnBlock;
const dartCasing = (name, casing) => {
    if (casing === 'camelCase') {
        return (0, change_case_all_1.camelCase)(name);
    }
    else if (casing === 'PascalCase') {
        return (0, change_case_all_1.pascalCase)(name);
    }
    else if (casing === 'snake_case') {
        return (0, change_case_all_1.snakeCase)(name);
    }
    return name;
};
exports.dartCasing = dartCasing;
/**
 * checks whether name is a Dart Language keyword
 * @param identifier The name or identifier to be checked
 * @returns `true` if name is a Dart Language keyword, otherwise `false`
 */
const isDartKeyword = (identifier) => plugin_config_js_1.DART_KEYWORDS[identifier] !== undefined;
exports.isDartKeyword = isDartKeyword;
/**
 * Ensures that the blockName isn't a valid Dart language reserved keyword.
 * It wraps the identifier with the prefix and suffix then transforms the casing as specified in the config
 * @param config
 * @param name
 * @param typeName
 * @returns
 */
const escapeDartKeyword = (config, blockAppliesOn, identifier, typeName, fieldName) => {
    if ((0, exports.isDartKeyword)(identifier)) {
        const [prefix, suffix] = config_value_js_1.Config.escapeDartKeywords(config, blockAppliesOn, typeName, fieldName);
        return `${prefix}${identifier}${suffix}`;
    }
    return identifier;
};
exports.escapeDartKeyword = escapeDartKeyword;
const atJsonKeyDecorator = ({ defaultValue, disallowNullValue, fromJson, ignore, includeIfNull, name, required, toJson, }) => {
    const body = [
        (0, exports.stringIsNotEmpty)(defaultValue) ? `defaultValue: ${defaultValue}` : undefined,
        disallowNullValue ? `disallowNullValue: ${disallowNullValue}` : undefined,
        (0, exports.stringIsNotEmpty)(fromJson) ? `fromJson: ${fromJson}` : undefined,
        ignore ? `ignore: ${ignore}` : undefined,
        includeIfNull ? `includeIfNull: ${includeIfNull}` : undefined,
        (0, exports.stringIsNotEmpty)(name) ? `name: '${name}'` : undefined,
        required ? `required: ${required}` : undefined,
        (0, exports.stringIsNotEmpty)(toJson) ? `toJson: ${toJson}` : undefined,
    ]
        .filter(value => value !== undefined)
        .join(',');
    return (0, exports.stringIsNotEmpty)(body) ? `@JsonKey(${body})\n` : '';
};
exports.atJsonKeyDecorator = atJsonKeyDecorator;
const stringIsNotEmpty = (str) => (str === null || str === void 0 ? void 0 : str.length) > 0;
exports.stringIsNotEmpty = stringIsNotEmpty;
//#endregion
