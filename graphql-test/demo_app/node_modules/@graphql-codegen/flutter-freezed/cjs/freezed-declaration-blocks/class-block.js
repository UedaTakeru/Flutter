"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassBlock = void 0;
const graphql_1 = require("graphql");
const visitor_plugin_common_1 = require("@graphql-codegen/visitor-plugin-common");
const config_value_js_1 = require("../config/config-value.js");
const pattern_js_1 = require("../config/pattern.js");
const plugin_config_js_1 = require("../config/plugin-config.js");
const utils_js_1 = require("../utils.js");
const factory_block_js_1 = require("./factory-block.js");
const index_js_1 = require("./index.js");
class ClassBlock {
    static build(config, node) {
        const typeName = pattern_js_1.TypeName.fromString(node.name.value);
        const _className = index_js_1.Block.buildBlockName(config, plugin_config_js_1.APPLIES_ON_CLASS, typeName.value, typeName, undefined, 'PascalCase');
        let block = '';
        // the comments should be  on the factory block instead
        // block += Block.buildComment(node);
        block += this.buildDecorators(config, node);
        block += this.buildHeader(config, typeName, _className);
        block += this.buildBody(config, node);
        block += this.buildFooter(_className);
        return block;
    }
}
exports.ClassBlock = ClassBlock;
ClassBlock.buildDecorators = (config, node) => {
    const freezedDecorator = ClassBlock.buildFreezedDecorator(config, node);
    // TODO: consider implementing custom decorators
    return [freezedDecorator].join('');
};
ClassBlock.buildFreezedDecorator = (config, node) => {
    // this is the start of the pipeline of decisions to determine which Freezed decorator to use
    return ClassBlock.decorateAsFreezed(config, node);
};
ClassBlock.decorateAsFreezed = (config, node) => {
    const typeName = pattern_js_1.TypeName.fromString(node.name.value);
    const copyWith = config_value_js_1.Config.copyWith(config, typeName);
    const equal = config_value_js_1.Config.equal(config, typeName);
    const makeCollectionsUnmodifiable = config_value_js_1.Config.makeCollectionsUnmodifiable(config, typeName);
    const unionKey = config_value_js_1.Config.unionKey();
    const unionValueCase = config_value_js_1.Config.unionValueCase();
    const body = [
        copyWith !== undefined ? `copyWith: ${copyWith},\n` : undefined,
        equal !== undefined ? `equal: ${equal},\n` : undefined,
        makeCollectionsUnmodifiable !== undefined
            ? `makeCollectionsUnmodifiable: ${makeCollectionsUnmodifiable},\n`
            : undefined,
        unionKey !== undefined ? `unionKey: ${unionKey},\n` : undefined,
        unionValueCase !== undefined ? `unionValueCase: '${unionValueCase}',\n` : undefined,
    ]
        .filter(value => value !== undefined)
        .map(value => (0, visitor_plugin_common_1.indent)(value))
        .join('');
    return (0, utils_js_1.stringIsNotEmpty)(body)
        ? `@Freezed(\n${body})\n`
        : ClassBlock.decorateAsUnfreezed(config, node);
};
ClassBlock.decorateAsUnfreezed = (config, node) => {
    const typeName = pattern_js_1.TypeName.fromString(node.name.value);
    const immutable = config_value_js_1.Config.immutable(config, typeName);
    const mutableInputs = config_value_js_1.Config.mutableInputs(config, typeName);
    const mutable = immutable !== true || (node.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION && mutableInputs);
    return mutable ? '@unfreezed\n' : '@freezed\n';
};
ClassBlock.buildHeader = (config, typeName, _className) => {
    const privateEmptyConstructor = config_value_js_1.Config.privateEmptyConstructor(config, typeName)
        ? (0, visitor_plugin_common_1.indent)(`const ${_className}._();\n\n`)
        : '';
    return `class ${_className} with _$${_className} {\n${privateEmptyConstructor}`;
};
ClassBlock.buildBody = (config, node) => {
    var _a;
    const className = pattern_js_1.TypeName.fromString(node.name.value);
    let body = '';
    if ((0, utils_js_1.nodeIsObjectType)(node)) {
        body += factory_block_js_1.FactoryBlock.serializeDefaultFactory(className);
    }
    else if (node.kind === graphql_1.Kind.UNION_TYPE_DEFINITION) {
        body += ((_a = node.types) !== null && _a !== void 0 ? _a : [])
            .map(value => {
            const factoryName = pattern_js_1.TypeName.fromString(value.name.value);
            return factory_block_js_1.FactoryBlock.serializeUnionFactory(className, factoryName);
        })
            .join('');
    }
    body += config_value_js_1.Config.mergeTypes(config, className)
        .map(factoryName => {
        return factory_block_js_1.FactoryBlock.serializeMergedFactory(className, factoryName);
    })
        .join('');
    return body;
};
ClassBlock.buildFooter = (_className) => {
    return (0, visitor_plugin_common_1.indent)(`factory ${_className}.fromJson(Map<String, dynamic> json) => _$${_className}FromJson(json);\n}\n\n`);
};
