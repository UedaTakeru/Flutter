"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = void 0;
const change_case_all_1 = require("change-case-all");
const graphql_1 = require("graphql");
const config_value_js_1 = require("../config/config-value.js");
const pattern_js_1 = require("../config/pattern.js");
const utils_js_1 = require("../utils.js");
const class_block_js_1 = require("./class-block.js");
const enum_block_js_1 = require("./enum-block.js");
const factory_block_js_1 = require("./factory-block.js");
class Block {
}
exports.Block = Block;
Block.buildImportStatements = (fileName) => {
    if (fileName.length < 1) {
        throw new Error('fileName is required and must not be empty');
    }
    const segments = fileName.split('/');
    const target = segments[segments.length - 1];
    const expectedFileName = (0, change_case_all_1.snakeCase)(target.replace(/\.dart/g, ''));
    return [
        `import 'package:freezed_annotation/freezed_annotation.dart';\n`,
        `import 'package:flutter/foundation.dart';\n\n`,
        `part '${expectedFileName}.freezed.dart';\n`,
        `part '${expectedFileName}.g.dart';\n\n`,
    ].join('');
};
/**
 * Transforms the AST nodes into  Freezed classes/models
 * @param config The plugin configuration object
 * @param node the AST node passed by the schema visitor
 * @param nodeRepository A map that stores the name of the Graphql Type as the key and it AST node as the value. Used to build FactoryBlocks from placeholders for mergedInputs and Union Types
 * @returns a string output of a `FreezedDeclarationBlock` which represents a Freezed class/model in Dart
 */
Block.build = (config, node, nodeRepository) => {
    // ignore these...
    const typeName = pattern_js_1.TypeName.fromString(node.name.value);
    if (['Query', 'Mutation', 'Subscription', ...config_value_js_1.Config.ignoreTypes(config, typeName)].includes(typeName.value)) {
        return '';
    }
    // registers all the ObjectTypes
    if ((0, utils_js_1.nodeIsObjectType)(node)) {
        nodeRepository.register(node);
    }
    return node.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION
        ? enum_block_js_1.EnumBlock.build(config, node)
        : class_block_js_1.ClassBlock.build(config, node);
};
Block.buildComment = (node) => {
    var _a;
    const comment = (_a = node === null || node === void 0 ? void 0 : node.description) === null || _a === void 0 ? void 0 : _a.value;
    return comment && (comment === null || comment === void 0 ? void 0 : comment.length) > 0
        ? `${comment
            .trim()
            .split(/\n/gm)
            .map(c => `/// ${c.trim().replace(/^#/, '')}\n`)
            .join('')}`
        : '';
};
Block.buildBlockName = (config, blockAppliesOn, identifier, typeName, fieldName, blockCasing) => {
    identifier = (0, utils_js_1.dartCasing)(identifier, blockCasing);
    if ((0, utils_js_1.isDartKeyword)(identifier)) {
        return (0, utils_js_1.escapeDartKeyword)(config, blockAppliesOn, identifier, typeName, fieldName);
    }
    return identifier;
};
Block.tokens = {
    defaultFactory: '==>default_factory==>',
    unionFactory: '==>union_factory==>',
    mergedFactory: '==>merged_factory==>',
    fromJsonToJson: '==>from_json_to_json==>',
};
Block.regexpForToken = (tokenName) => {
    return RegExp(`${Block.tokens[tokenName]}.+\n`, 'gm');
};
Block.replaceTokens = (config, nodeRepository, generatedBlocks) => generatedBlocks
    .map(block => {
    block = Block.replaceDefaultFactoryToken(block, config, nodeRepository);
    block = Block.replaceNamedFactoryToken(block, config, nodeRepository, 'unionFactory');
    block = Block.replaceNamedFactoryToken(block, config, nodeRepository, 'mergedFactory');
    // TODO: one more for parameter fromJson and toJson tokens inside @JsonKey
    return block;
})
    .join('');
Block.replaceDefaultFactoryToken = (block, config, nodeRepository) => block.replace(Block.regexpForToken('defaultFactory'), token => {
    const pattern = token.replace(Block.tokens.defaultFactory, '').trim();
    const [className, blockAppliesOn] = pattern.split('==>');
    return factory_block_js_1.FactoryBlock.deserializeFactory(config, nodeRepository, blockAppliesOn.split(','), pattern_js_1.TypeName.fromString(className));
});
Block.replaceNamedFactoryToken = (block, config, nodeRepository, blockType) => block.replace(Block.regexpForToken(blockType), token => {
    const pattern = token.replace(Block.tokens[blockType], '').trim();
    const [className, factoryName, blockAppliesOn] = pattern.split('==>');
    return factory_block_js_1.FactoryBlock.deserializeNamedFactory(config, nodeRepository, blockAppliesOn.split(','), pattern_js_1.TypeName.fromString(className), pattern_js_1.TypeName.fromString(factoryName));
});
