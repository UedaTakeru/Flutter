/**
 * A list of GraphQL Type Names
 */
type TypeNames = TypeName | TypeName[];
/**
 * A list of field names of a GraphQL Type
 */
type FieldNames = FieldName | FieldName[];
/**
 * @name TypeName
 * @description represents a single valid GraphQL Type Name used in the GraphQL Schema provided
 * @exampleMarkdown
 * ```ts filename:"config.ts"
 * // returns a TypeName
 * let typeName: TypeName = TypeName.fromString('Droid');
 *
 * // to configure a FactoryBlock, use the `TypeName.fromUnionOfTypeNames(className, factoryName)`
 * let typeName: TypeName = TypeName.fromUnionOfTypeNames(SearchResult, Droid);

 * // the following will throw an error
 * // can contain only a single value...
 * let typeName: TypeName = TypeName.fromString('Droid, Human'); // throws an Error
 *
 * // value can not be an empty string...
 * let typeName: TypeName = TypeName.fromString(''); // throws an Error
 *
 * // value must contain only AlphaNumeric characters only...
 * let typeName: TypeName = TypeName.fromString('Invalid.Name'); // throws an Error
 * ```
 */
export declare class TypeName {
    private _value;
    private constructor();
    get value(): string;
    static get allTypeNames(): string;
    static fromUnionOfTypeNames: (className: TypeName, factoryName: TypeName) => TypeName;
    static fromString: (value: string) => TypeName;
}
/**
 * @name FieldName
 * @description Represents a single valid name of a field belong to a Graphql Type.
 * @exampleMarkdown
 * ```ts filename:"config.ts"
 * // returns a FieldName
 * let fieldName: FieldName = FieldName.fromString('id');
 *
 * // the following will throw an error
 * // can contain only a single value...
 * let fieldName: FieldName = FieldName.fromString('id, name'); // throws an Error
 *
 * // value can not be an empty string...
 * let fieldName: FieldName = FieldName.fromString(''); // throws an Error
 *
 * // value must contain only AlphaNumeric characters only...
 * let fieldName: FieldName = FieldName.fromString('Invalid.Name'); // throws an Error
 * ```
 */
export declare class FieldName {
    private _value;
    private constructor();
    get value(): string;
    static get allFieldNames(): string;
    static fromString: (value: string) => FieldName;
}
/**
 * @name Pattern
 * @description The base class for TypeNamePattern and FieldNamePattern
 * @see {@link url TypeNamePattern}
 * @see {@link url FieldNamePattern}
 */
export declare class Pattern {
    private _value;
    protected constructor(value: string);
    get value(): string;
    protected static fromString: (value: string) => Pattern;
    static attemptMatchAndConfigure: (pattern: FieldNamePattern, typeName: TypeName, fieldName?: FieldName) => MatchAndConfigure;
    static compose: (data: Pattern[]) => Pattern;
    static split: (pattern: Pattern) => Pattern[];
    static getMatchList: (patternType: 'TypeNamePattern' | 'FieldNamePattern' | 'Pattern') => string[];
    /**
     * finds the last pattern that configures the typeName and/or fieldName given
     * @param pattern
     * @param typeName
     * @param fieldName
     * @returns true if a pattern marks the typeName and or fieldName given to be configured, otherwise false
     */
    static findLastConfiguration: (pattern: Pattern, typeName: TypeName, fieldName?: FieldName) => boolean;
}
/**
 *  @name TypeNamePattern
 *
 * @description A compact string of patterns used in the config for granular configuration of Graphql Types.
 *
 * The string can contain one or more patterns, each pattern ends with a semi-colon (`;`).
 *
 * To apply an option to all Graphql Types or all fields, use the allTypeNames (`@*TypeNames`) tokens.
 *
 * Wherever you use the allTypeNames token, know very well that you can make some exceptions. After all, to every rule, there is an exception.
 *
 * A **square bracket** (`[]`) is used to specify what should be included and a **negated square bracket** (`-[]`) is used to specify what should be excluded.
 *
 * Manually typing out a pattern may be prone to typos resulting in invalid patterns therefore the [`TypeNamePattern`]() class exposes some builder methods to be used in the plugin config file.
 *
 * ## Available Builder Methods and the patterns they make
 * ```ts
 * const Droid = TypeName.fromString('Droid');
 * const Starship = TypeName.fromString('Starship');
 * const Human = TypeName.fromString('Human');
 * const Movie = TypeName.fromString('Movie');

 *
 * // Configuring specific Graphql Types
 * const pattern = TypeNamePattern.forTypeNames([Droid, Starship]);
 * console.log(pattern); // "Droid;Starship;"
 *
 * // Configuring all Graphql Types
 * const pattern = TypeNamePattern.forAllTypeNames();
 * console.log(pattern); // "@*TypeNames;"

 * // Configuring all Graphql Types except those specified in the exclusion list of TypeNames
 * const pattern = TypeNamePattern.forAllTypeNamesExcludeTypeNames([Droid, Starship]);
 * console.log(pattern); // "@*TypeNames-[Droid,Starship];"
 *
 */
export declare class TypeNamePattern extends Pattern {
    private constructor();
    static forTypeNames: (typeNames: TypeNames) => TypeNamePattern;
    static regexpForTypeNames: RegExp;
    static matchAndConfigureTypeNames: (pattern: TypeNamePattern, typeName: TypeName) => MatchAndConfigure;
    static forAllTypeNames: () => TypeNamePattern;
    static regexpForAllTypeNames: RegExp;
    static matchAndConfigureAllTypeNames: (pattern: TypeNamePattern, typeName: TypeName) => MatchAndConfigure;
    static forAllTypeNamesExcludeTypeNames: (typeNames: TypeNames) => TypeNamePattern;
    static regexpForAllTypeNamesExcludeTypeNames: RegExp;
    static matchAndConfigureAllTypeNamesExcludeTypeNames: (pattern: TypeNamePattern, typeName: TypeName) => MatchAndConfigure;
}
/**
 *  @name FieldNamePattern
 *
 * @description A compact string of patterns used in the config for granular configuration the fields of a Graphql Type
 *
 * The string can contain one or more patterns, each pattern ends with a semi-colon (`;`).
 *
 * A dot (`.`) is used to separate the TypeName from the FieldNames in each pattern.
 *
 * To apply an option to all Graphql Types or all fields, use the allTypeNames (`@*TypeNames`) and allFieldNames (`@*FieldNames`) tokens respectively.
 *
 * Wherever you use the allTypeNames and the allFieldNames, know very well that you can make some exceptions. After all, to every rule, there is an exception.
 *
 * A **square bracket** (`[]`) is used to specify what should be included and a **negated square bracket** (`-[]`) is used to specify what should be excluded.
 *
 * Manually typing out a pattern may be prone to typos resulting in invalid patterns therefore the [`FieldName`]() class exposes some builder methods to be used in your plugin config file.
 *
 * ## Available Builder Methods and the patterns they make
 * ```ts
 * const Droid = TypeName.fromString('Droid');
 * const Starship = TypeName.fromString('Starship');
 * const Human = TypeName.fromString('Human');
 * const Movie = TypeName.fromString('Movie');
 *
 * const id = FieldName.fromString('id');
 * const name = FieldName.fromString('name');
 * const friends = FieldName.fromString('friends');
 * const friend = FieldName.fromString('friend');
 * const title = FieldName.fromString('title');
 * const episode = FieldName.fromString('episode');
 * const length = FieldName.fromString('length');
 *
 * // Configuring specific fields of a specific Graphql Type
 * const pattern = FieldNamePattern.forFieldNamesOfTypeName([
 *   [Droid, [id, name, friends]], // individual
 *   [Human, [id, name, title]], // individual
 *   [Starship, [name, length]], // individual
 * ]);
 * console.log(pattern); // "Droid.[id,name,friends];Human.[id,name,title];Starship.[name,length];"
 *
 * // Configuring all fields of a specific Graphql Type
 * const pattern = FieldNamePattern.forAllFieldNamesOfTypeName([Droid, Movie]);
 * console.log(pattern); // "Droid.@*FieldNames;Movie.@*FieldNames;"
 *
 * // Configuring all fields except those specified in the exclusion list of FieldNames for a specific GraphQL Type
 * const pattern = FieldNamePattern.forAllFieldNamesExcludeFieldNamesOfTypeName([
 *   [Droid, [id, name, friends]], // individual
 *   [Human, [id, name, title]], // individual
 *   [Starship, [name, length]], // individual
 * ]);
 * console.log(pattern); // "Droid.@*FieldNames-[id,name,friends];Human.@*FieldNames-[id,name,title];Starship.@*FieldNames-[name,length];"
 *
 * // Configuring specific fields of all Graphql Types
 * const pattern = FieldNamePattern.forFieldNamesOfAllTypeNames([id, name, friends]);
 * console.log(pattern); // "@*TypeNames.[id,name,friends];"
 *
 * // Configuring all fields of all Graphql Types
 * const pattern = FieldNamePattern.forAllFieldNamesOfAllTypeNames();
 * console.log(pattern); // "@*TypeNames.@*FieldNames;"
 *
 * // Configuring all fields except those specified in the exclusion list of FieldNames for all GraphQL Types
 * const pattern = FieldNamePattern.forAllFieldNamesExcludeFieldNamesOfAllTypeNames([id, name, friends]);
 * console.log(pattern); // "@*TypeNames.@*FieldNames-[id,name,friends];"
 *
 * // Configuring specific fields of all GraphQL Types except those specified in the exclusion list of TypeNames
 * const pattern = FieldNamePattern.forFieldNamesOfAllTypeNamesExcludeTypeNames([Droid, Human], [id, name, friends]);
 * console.log(pattern); // "@*TypeNames-[Droid,Human].[id,name,friends];"
 *
 * // Configuring all fields of all GraphQL Types except those specified in the exclusion list of TypeNames
 * const pattern = FieldNamePattern.forAllFieldNamesOfAllTypeNamesExcludeTypeNames([Droid, Human]);
 * console.log(pattern); // "@*TypeNames-[Droid,Human].@*FieldNames;"
 *
 * // Configuring all fields except those specified in the exclusion list of FieldNames of all GraphQL Types except those specified in the exclusion list of TypeNames
 * const pattern = FieldNamePattern.forAllFieldNamesExcludeFieldNamesOfAllTypeNamesExcludeTypeNames(
 *   [Droid, Human],
 *   [id, name, friends]
 * );
 * console.log(pattern); // "@*TypeNames-[Droid,Human].@*FieldNames-[id,name,friends];"
 * ```
 *
 */
export declare class FieldNamePattern extends Pattern {
    private constructor();
    static forFieldNamesOfTypeName: (data: [typeNames: TypeNames, fieldNames: FieldNames][]) => FieldNamePattern;
    static regexpForFieldNamesOfTypeName: RegExp;
    static matchAndConfigureFieldNamesOfTypeName: (pattern: FieldNamePattern, typeName: TypeName, fieldName: FieldName) => MatchAndConfigure;
    static forAllFieldNamesOfTypeName: (typeNames: TypeNames) => FieldNamePattern;
    static regexpForAllFieldNamesOfTypeName: RegExp;
    static matchAndConfigureAllFieldNamesOfTypeName: (pattern: FieldNamePattern, typeName: TypeName, fieldName: FieldName) => MatchAndConfigure;
    static forAllFieldNamesExcludeFieldNamesOfTypeName: (data: [typeNames: TypeNames, fieldNames: FieldNames][]) => FieldNamePattern;
    static regexpForAllFieldNamesExcludeFieldNamesOfTypeName: RegExp;
    static matchAndConfigureAllFieldNamesExcludeFieldNamesOfTypeName: (pattern: FieldNamePattern, typeName: TypeName, fieldName: FieldName) => MatchAndConfigure;
    static forFieldNamesOfAllTypeNames: (fieldNames: FieldNames) => FieldNamePattern;
    static regexpForFieldNamesOfAllTypeNames: RegExp;
    static matchAndConfigureFieldNamesOfAllTypeNames: (pattern: FieldNamePattern, typeName: TypeName, fieldName: FieldName) => MatchAndConfigure;
    static forAllFieldNamesOfAllTypeNames: () => FieldNamePattern;
    static regexpForAllFieldNamesOfAllTypeNames: RegExp;
    static matchAndConfigureAllFieldNamesOfAllTypeNames: (pattern: FieldNamePattern, typeName: TypeName, fieldName: FieldName) => MatchAndConfigure;
    static forAllFieldNamesExcludeFieldNamesOfAllTypeNames: (fieldNames: FieldNames) => FieldNamePattern;
    static regexpForAllFieldNamesExcludeFieldNamesOfAllTypeNames: RegExp;
    static matchAndConfigureAllFieldNamesExcludeFieldNamesOfAllTypeNames: (pattern: FieldNamePattern, typeName: TypeName, fieldName: FieldName) => MatchAndConfigure;
    static forFieldNamesOfAllTypeNamesExcludeTypeNames: (typeNames: TypeNames, fieldNames: FieldNames) => FieldNamePattern;
    static regexpForFieldNamesOfAllTypeNamesExcludeTypeNames: RegExp;
    static matchAndConfigureFieldNamesOfAllTypeNamesExcludeTypeNames: (pattern: FieldNamePattern, typeName: TypeName, fieldName: FieldName) => MatchAndConfigure;
    static forAllFieldNamesOfAllTypeNamesExcludeTypeNames: (typeNames: TypeNames) => FieldNamePattern;
    static regexpForAllFieldNamesOfAllTypeNamesExcludeTypeNames: RegExp;
    static matchAndConfigureAllFieldNamesOfAllTypeNamesExcludeTypeNames: (pattern: FieldNamePattern, typeName: TypeName, fieldName: FieldName) => MatchAndConfigure;
    static forAllFieldNamesExcludeFieldNamesOfAllTypeNamesExcludeTypeNames: (typeNames: TypeNames, fieldNames: FieldNames) => FieldNamePattern;
    static regexpForAllFieldNamesExcludeFieldNamesOfAllTypeNamesExcludeTypeNames: RegExp;
    static matchAndConfigureAllFieldNamesExcludeFieldNamesOfAllTypeNamesExcludeTypeNames: (pattern: FieldNamePattern, typeName: TypeName, fieldName: FieldName) => MatchAndConfigure;
}
export type MatchAndConfigure = Record<string, {
    matchFound: boolean;
    shouldBeConfigured: boolean;
}>;
export {};
