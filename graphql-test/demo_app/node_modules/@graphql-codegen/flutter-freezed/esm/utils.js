//#region helpers
import { camelCase, pascalCase, snakeCase } from 'change-case-all';
import { Kind, } from 'graphql';
import { Config } from './config/config-value.js';
import { DART_KEYWORDS, } from './config/plugin-config.js';
export const strToList = (str) => str.length < 1 ? [] : str.split(/\s*,\s*/gim).filter(s => s.length > 0);
export const arrayWrap = (value) => value === undefined ? [] : Array.isArray(value) ? value : [value];
export const resetIndex = (regexp) => (regexp.lastIndex = 0);
export const nodeIsObjectType = (node) => node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
export const appliesOnBlock = (configAppliesOn, blockAppliesOn) => configAppliesOn.some(a => blockAppliesOn.includes(a));
export const dartCasing = (name, casing) => {
    if (casing === 'camelCase') {
        return camelCase(name);
    }
    else if (casing === 'PascalCase') {
        return pascalCase(name);
    }
    else if (casing === 'snake_case') {
        return snakeCase(name);
    }
    return name;
};
/**
 * checks whether name is a Dart Language keyword
 * @param identifier The name or identifier to be checked
 * @returns `true` if name is a Dart Language keyword, otherwise `false`
 */
export const isDartKeyword = (identifier) => DART_KEYWORDS[identifier] !== undefined;
/**
 * Ensures that the blockName isn't a valid Dart language reserved keyword.
 * It wraps the identifier with the prefix and suffix then transforms the casing as specified in the config
 * @param config
 * @param name
 * @param typeName
 * @returns
 */
export const escapeDartKeyword = (config, blockAppliesOn, identifier, typeName, fieldName) => {
    if (isDartKeyword(identifier)) {
        const [prefix, suffix] = Config.escapeDartKeywords(config, blockAppliesOn, typeName, fieldName);
        return `${prefix}${identifier}${suffix}`;
    }
    return identifier;
};
export const atJsonKeyDecorator = ({ defaultValue, disallowNullValue, fromJson, ignore, includeIfNull, name, required, toJson, }) => {
    const body = [
        stringIsNotEmpty(defaultValue) ? `defaultValue: ${defaultValue}` : undefined,
        disallowNullValue ? `disallowNullValue: ${disallowNullValue}` : undefined,
        stringIsNotEmpty(fromJson) ? `fromJson: ${fromJson}` : undefined,
        ignore ? `ignore: ${ignore}` : undefined,
        includeIfNull ? `includeIfNull: ${includeIfNull}` : undefined,
        stringIsNotEmpty(name) ? `name: '${name}'` : undefined,
        required ? `required: ${required}` : undefined,
        stringIsNotEmpty(toJson) ? `toJson: ${toJson}` : undefined,
    ]
        .filter(value => value !== undefined)
        .join(',');
    return stringIsNotEmpty(body) ? `@JsonKey(${body})\n` : '';
};
export const stringIsNotEmpty = (str) => (str === null || str === void 0 ? void 0 : str.length) > 0;
//#endregion
